-- This is a consolidated, clean migration file for the entire database schema.
-- It is designed to be run on a fresh database and is idempotent where possible.

-- Section 1: Extensions
-- Enable the UUID extension for generating unique identifiers.
create extension if not exists "uuid-ossp" with schema "extensions";


-- Section 2: Custom Types
-- We use a DO block to safely create the ENUM type only if it doesn't already exist.
-- This is the correct way to avoid the "syntax error at or near 'NOT'" issue.
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
        CREATE TYPE public.user_role AS ENUM ('admin', 'customer', 'vendor');
    END IF;
END$$;


-- Section 3: Table Creation
-- Create the customers table.
create table if not exists public.customers (
    id uuid not null primary key,
    full_name text,
    phone_number text unique,
    water_score integer not null default 0
);
comment on column public.customers.id is 'Links to auth.users.id';

-- Create the vendors table.
create table if not exists public.vendors (
    id uuid not null primary key,
    full_name text,
    phone_number text unique,
    is_verified boolean not null default false,
    address text
);
comment on column public.vendors.id is 'Links to auth.users.id';

-- Create the user_roles table.
create table if not exists public.user_roles (
    id bigint generated by default as identity primary key,
    user_id uuid not null references auth.users(id) on delete cascade,
    role user_role not null,
    created_at timestamptz not null default now(),
    unique(user_id, role)
);


-- Section 4: Row Level Security (RLS)
-- Enable RLS for all tables.
alter table public.customers enable row level security;
alter table public.vendors enable row level security;
alter table public.user_roles enable row level security;

-- Drop all existing policies to ensure a clean slate before creating new ones.
DROP POLICY IF EXISTS "Users can view their own profile" ON public.customers;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.customers;
DROP POLICY IF EXISTS "Customers can view verified vendors" ON public.vendors;
DROP POLICY IF EXISTS "Users can view their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can insert their own roles" ON public.user_roles;

-- Create policies for the 'customers' table.
CREATE POLICY "Users can view their own profile" ON public.customers FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.customers FOR UPDATE USING (auth.uid() = id);

-- Create policies for the 'vendors' table.
CREATE POLICY "Customers can view verified vendors" ON public.vendors FOR SELECT TO authenticated USING (is_verified = true);

-- Create policies for the 'user_roles' table.
CREATE POLICY "Users can view their own roles" ON public.user_roles FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own roles" ON public.user_roles FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);


-- Section 5: Functions and Triggers
-- This function automatically creates a profile entry when a new user signs up.
create or replace function public.handle_new_user()
returns trigger as $$
begin
  -- This will be expanded later to handle different roles.
  -- For now, it defaults to creating a customer profile.
  insert into public.customers (id, full_name, phone_number)
  values (new.id, new.raw_user_meta_data->>'full_name', new.phone);
  return new;
end;
$$ language plpgsql security definer;

-- This trigger calls the function when a new user is created in the auth system.
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

